---
layout: "post"
title: "\"Bitcoin and Cryptocurrency Tech\"读书笔记"
categories: "blog"
tags: ['blochchain']
published: false
comments: true
script: [post.js]
excerpted: |
    读书笔记...
---

* TOC
{:toc}

# 1. 密码学和数字货币

## 1.1 哈希函数

### 1.1.1 密码哈希函数的属性

传统的哈希函数有以下几个属性：

1. 输入可以是任意长度
2. 输出是固定长度
3. 给定输入（对于n比特长度），可以在固定时间内算出输出（O(n)）

但是对于密码哈希函数，有以下几个额外的安全性需求：

1. collision resisitence

  定义：

  > A hash function H is said to be collision resistent if it is infeasible to find two value, x and y, such that x != y, yet H(x) = H(y)

  应用：信息摘要（message digest）

2. hiding

  定义：

  > A hash function H is hiding if: when a secret value r is chosen from a probability distribution that has high min-entropy, then given H(r||x) it is infeasible to find x.
  
  应用：commitment (配合**collision resisitence** )

3. puzzle friendness

    定义：

    > A hash function H is said to be puzzle-friendly if for every possible n-bit output value y, if k is chosen from a distribution with high min-entropy, then it is infeasible to find x such that H(k||x)=y in time significantly less than 2**n.

    应用：search puzzle

### 1.1.2 SHA-256 

比特币的实现中大量使用SHA-256作为密码哈希函数，该算法只作用于有限长度的输入(758bit -> 256bit)，但是可以通过 **Merkle-Damgard 变换** 使他支持任意长度输入:

    我们称实际的转换函数（作用于有限长度）为压缩函数，可以证明，如果压缩函数是 collision-resistent 的，那么变换后的哈希函数也是 collision-resistent.

    具体的变换过程如下所示：

         ----------------------------------------------
         |   msg1     |   msg2   |   ...   |  msgn    |
         | (512bit)   | (512bit) |   ...   |(512bit)  |
         ----------------------------------------------
              |            |                    |
              +->          +->                  +->
       IV ------>  C --------> C -----------------> C ----> Hash
    (256bit)                                              (256bit)


    注意：IV被复用到每一次的SHA-256哈希计算中，作为初始向量。


## 1.2 数据结构

### 1.2.1 哈希指针

定义： 

> A hash pointer is basically a pointer to the place where some information is stored, together with the pointer stores a cryptographic hash of the information.

      +---------+
      v         |
    +----+    H( )
    |data|
    +----+

普通的指针是用于获取数据，哈希指针不但可以获取数据，还可以验证该数据是否被篡改.

### 1.2.2 区块链

区块链实际上就是在传统链表的基础上用哈希指针代替传统指针的一种数据结构：

                          ----            --------------+    --------------+    H( ) <-- header hash
                          |               |             |    |             |      |   
         +-----------+    |               |   +-----------+  |   +-----------+    |   
         |genesis blk|    |               |   | prev: H( )|  |   | prev: H( )|    |   
         +-----------+  <-+     ...     <-+   +-----------+<-+   +-----------+ <--+   
         |    data   |                        |    data   |      |    data   | 
         +-----------+                        +-----------+      +-----------+       

区块链的特点有：

- 防篡改：只要记住`header hash`，那么可以防止他人修改或者删除已有区块

### 1.2.3 Merkle trees

Merkle tree 实际上就是在传统二叉树的基础上用哈希指针代替传统指针的一种数据结构：

                                root
                                  |
                                  v
                              H( ) H( )
                                |    |
                         +------+    +------+
                         |                  |
                         v                  v
                    H( ) H( )           H( ) H( )
                      |    |              |    |
                      v    v              v    v
                  +----+ +----+        +----+ +----+
                  |data| |data|        |data| |data|
                  +----+ +----+        +----+ +----+

Merkle trees的特点有：

- 防篡改：只要记住`root hash`，那么可以防止他人修改或者删除已有区块
- 方便验证某个区块是一个成员：只要验证该区块（data）所在的路径即可（O(log(n))）
- 方便验证某个区块不是一个成员：对于一个 **有序** Merkle tree, 如果一个 *排在目标区块之前的区块*的路径 和一个 *排在目标区块之后的区块*的路径 相邻，那么可以证明目标区块不是这颗Merkle tree的成员

### 1.2.4 更多数据结构

只要数据结构是无环(acyclic)的，那么我们可以在任何基于指针的数据结构中用哈希指针代替，从而创造处新的数据结构(例如：有向无环图)

## 1.3 数字签名

数字签名需要具备以下两个属性：

1. 只有你可以签名，但是所有人都可以验证这是你的签名
2. 你的每一个签名只能用于一个文档，也就是说别人不可以将你在A文档上的签名用于B文档

### 1.3.1 机制

数字签名机制包括如下三个算法：

- `(sk, pk) := generateKeys(keysize)`
- `sig := sign(sk, message)`
- `isValid := verify(pk, message, sig)`

以上的算法满足如下条件：

- `verify`(pk, message, `sign`(sk, message)) == `true`
- Signatures are existentially unforgeable

### 1.3.2 数字签名的实践

- 签名函数(`sign`)需要有高度随机性，因为如果不够随机性，那么会泄漏你的私钥
- 由于签名函数(`sign`)一般只接收固定长度的输入，签名的`message`一般取待签名的内容的哈希
- 签名的`message`可以是一个哈希指针，这样这个签名就涵盖了整个数据结构

比特币的签名机制使用**ECDSA**算法。

# 2. 比特币去中心化

## 2.1 分布式一致性

分布式一致性协议的定义如下：

> There are _n_ nodes that each have an input value. Some of these nodes are faulty or malicious. A distributed consensus protocol has the following two properties:
>- It must terminate with all honest nodes in agreement on the value
>- The value must have been generated by an honest node

比特币在实现一致性协议的过程中，要解决两个问题：

1. 不完美的网络环境，例如网络延迟，单点故障等
2. 作恶节点的存在

这两个问题会带来各种衍生问题，例如网络延迟导致了比特币网络中的节点之间无法对时间先后达成一致（即不存在全局时间）。

### 2.1.1 Impossibility result

著名的一致性问题“拜占庭将军问题”的结论是：当作恶节点超过1/3的时候，该网络的一致性无法保证。比特币网络由于其开放的特性，是很容易产生作恶节点超过1/3的情况的。然而，比特币引入了经济学激励的方式，巧妙地规避了上述限制，导致原本可能作恶的节点“不太可能”作恶 (因为它们没有作恶的动机)。

另一方面，比特币的共识算法实现的是最终一致性，随着时间的推移才能认为某个区块是否生效。因此，在比特币中也引入了“确认”的概念（6个后续区块加入之后，认为当前区块有效）。

## 2.2 一致性算法

简化版的Bitcoin一致性算法如下：

> _The algorithm is simplified in that it assumes the ability to select a random node in a manner that is not vulnerable to Sybil attacks.
>
> 1. New transactions are broadcast to all nodes
> 2. Each node collects new trasactions into a block
> 3. In each round a __random__ node gets to broadcast its block
> 4. Other nodes accept the block only if all transactions in it are valid(UTXO)
> 5. Nodes express their acceptance of the block by including its hash in the next block they create

对于以下各种可能的作恶行为，看看该算法是如何避免的：

1. **盗窃不属于自己的比特币**: Alice想将不属于她的比特币转到她账户下. 

    这是不肯能的，因为Alice没有该比特币持有人的私钥，因此她无法完成数字签名，也即该交易是一个无效的交易，会被其他节点所拒绝。

2. **拒绝提供服务**：Alice有选择的挑选交易加入到下一个区块

    这是可能发生的，但是即使Alice这次没有将你的交易写入区块链中，但是只要下一次是一个可信节点负责写区块，那你的交易就有可能被记录。

3. **双花**：Alice先向某个商户转了一笔钱，商户在看到这个交易在当前区块链之后就认为已经生效，于是给予Alice服务/商品；然而，Alice获得了下一个写入区块的权利，于是她从刚才写入的区块的前一个区块插入新的区块，于是产生了分支：

        B1 -> B2 -> B3 (Alice -> merchant)
                \-> B2.1 (fork)


