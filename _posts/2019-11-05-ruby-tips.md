---
layout: "post"
title: "Ruby Tips"
categories: "blog"
tags: ['programming language', 'ruby']
published: True
comments: true
script: [post.js]
excerpted: |
---

* TOC
{:toc}

# `include` 陷阱

`include` 定义：

> `include(module, ...)` → self click to toggle source
> 
> Invokes Module.append_features on each parameter in reverse order.

> `append_features(mod) → mod click to toggle source`
> 
> When this module is included in another, Ruby calls append_features in this module, passing it the receiving module in mod. Ruby's default implementation is to add the constants, methods, and module variables of this module to mod if this module has not already been added to mod or one of its ancestors. See also Module#include.

## include order

举个例子：

```ruby
module A
end

class Foo
  include A
end

p Foo.ancestors
```

输出：

```
[Foo, A, Object, Kernel, BasicObject]
```

对于`Foo`，它`include`了`A`，那么`A`在 *ancestor chain* 上就被 *append* 到 `Foo` 的后面。

对于多个`include`的情况：

```ruby
module A
end
module B
end

class Foo
  include A
  include B
end

class Bar
  include A, B
end

p Foo.ancestors
p Bar.ancestors
```

输出：

```
[Foo, B, A, Object, Kernel, BasicObject]
[Bar, A, B, Object, Kernel, BasicObject]
```

这里使用了两种include多个module的语法：

- 多次调用include: 每一次调用都会在 *ancestor chain* 中的 `Foo` 后面 *append* 被 include 的 module
- include method 传入多个 module参数：第一个参数被最后include，因此，出现在 *ancestor chain* 中 `Foo` 之后的第一个

## include scope

举个例子：

```ruby
module B
end

module A
  include B
end

module C
end

module B
  include C
end


p A.ancestors
p B.ancestors
```

输出：

```
[A, B]
[B, C]
```

这里之所以 `A.ancestors` 不等于 `[A, B, C]` ，是因为，上面的语句等价于：

```ruby
module A
end
module B
end
module C
end

A.include B
B.include C
```

在执行 `A.include B`之后的作用是将`B`append到`A`这个Class对象的*ancestor chain*中。接着，`B.include C`改变了`B`的 *ancestor chain*，但是`B`的 chain 不会影响 `A`的 chain。

这揭示了一点：如果某个类 `C` 已经include了某个 module `M`，之后如果 **open** `M` 在其中 `include` 了另一个 module `M2`，那么这不会作用于 `C`。只能 **open** `M` 在里边定义新的 method/const, 或者 **open** `C`，在里面 include `M2`.