---
layout: "post"
title: "leetcode难题笔记"
categories: "blog"
tags: ['algorithm']
published: True
comments: true
script: [post.js]
excerpted: |
    记录每一个hard题目的解决思路...
---

* TOC
{:toc}

本文仅记录思路，具体代码都在github的[repo](https://github.com/magodo/leetcode_practice.git)中。

# 0004 - 两个有序数组中的中位数

记`len(s1) == n, len(s2) == m`, 最直观的想法是一个一个去比较，算法复杂度为：O((n+m)/2) => O(n)。

不过，我们可以根据中位数的定义以及`s1`, `s2`为有序数组的条件，更快的获得答案。其思路大概为：由于我们要找第k (= (n+m)/2)个数，那么我们可以比较`s1`中第k/2个数和`s2`中第k/2个数（假设它们都有那么多数字）。假设`s1`中的那个数字更小，那么我们取`s1 <- s1[k/2:]`. **注意**：我们总是能够保证`s1`或者`s2`中至少有一个的前k/2个数是包含在合并的有序数组的前k个数中（反证法可证明）.

然后，再同上去比较两边的第(k-k/2)/2... 直到这个值 = 0为止。那么，我们基本已经去除中位数之前的所有数字，而这仅耗费了O(log(k/2)) => O(log(n)).

举个例子:

假设:

    s1 = []int{1,6,7,10,12}
    s2 = []int{2,4,6,7}

    k = 9/2 = 4

那么先找两边的第4/2 = 2个数：
    
    s1[1] = 6
    s2[1] = 4

由于s2[2]的更小，因此取 s2 = s2[2:] = []int{6,7}

接下来，找两边的第(4-2)/2=1个数：

    s1[0] = 1
    s2[0] = 6

因此：s1 = []int{6,7,10,12}

接下来，因为((4-2)/2-1)/2 = 0，因此，我们停止迭代。数数看，我们已经去除了前4个中的1+2=3个数字。接下来，（对于总共为奇数的情况）我们只要去掉最后一个数字，剩下的数字中最小的那个即为要找的中位数了。
